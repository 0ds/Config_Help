USERADD, USERMOD, USERDEL PASSWD,CHAGE:-
    useradd command is used to create new accounts in Linux
    usermod command used to modify the existing accounts in linux
    userdel command is used to delete local account in linux
    passwd command used assign password to local accounts or users.
    chage comamnd is used to view & modify users password expiry information
>>>>>>>>>>>>>>>>>>>>>> https://www.linuxtechi.com/linux-commands-to-manage-local-accounts   <<<<<<<<<<<<<<<<<<<<<<<

Let’s create a username ‘harry’ and assign password.
    [root@linuxtechi ~]# useradd harry ; echo -e "Roxicant@123#\nRoxicant@123#" | passwd harry
    Changing password for user harry.
    New password: Retype new password: passwd: all authentication tokens updated successfully.
    [root@linuxtechi ~]#
    
**Restricting users with certain for running certain command:-**
==============>
The normal user has been given permission to execute some commands which are available in /bin/ and /usr/local/bin/, So to remove those permissions and to restrict the user to run only particular set of commands, following steps shall be useful.

1. Create the restricted shell.
    # cp /bin/bash /bin/rbash
2. Modify the target user for the shell as restricted shell
  While creating user:
    # useradd -s /bin/rbash localuser
  For existing user:
    # usermod -s /bin/rbash localuser
    
-----------------------------------------------------------------------------------------------
PERMISSIONS:-
======================
Immutable/Mutable - concept

One more step can be added to restrict the user for making any modifications in their .bash_profile , as users can change it.
Run the following command to make the user localuser's .bash_profile file as immutable so that root/localuser can't modify it until root removes immutable permission from it.
    # chattr +i /home/localuser/.bash_profile

To remove immutable tag,
    # chattr -i /home/localuser/.bash_profile

Make file .bash_profile as immutable so that user localuser can't change the environmental paths.

------------------------------------------------------------------------------------------------
Redirection:-                                   +                           FileDescripter
 File 	                File Descriptor
Standard Input STDIN 	0
Standard Output STDOUT 	1
Standard Error STDERR 	2

Examples:-
1.    $ myprogram 2>errorsfile  ---------> error output
2.    # find . -name 'my*' 2>error.log  ----------------> This cmd looks for all files starting with "my" and if it has denied permissions to access the errot log will get redirected to this log file.
3.  Server Administrators frequently, list directories and store both error and standard output into a file, which can be processed later. Here is the command.
      # ls Documents ABC> dirlist 2>&1
      
 Summary

1    Each file in Linux has a corresponding File Descriptor associated with it
2   The keyboard is the standard input device while your screen is the standard output device
3    ">" is the output redirection operator. ">>" appends output to an existing file
4    "<" is the input redirection operator
5    ">&"re-directs output of one file to another.
6    You can re-direct error using its corresponding File Descriptor 2.

++++++FileDescripter++++++++
In simple words, when you open a file,the operating system creates an entry to represent that file and store the information 
about that opened file. So if there are 100 files opened in your OS then there will be 100 entries in OS (somewhere in kernel). 
These entries are represented by integers like (...100, 101, 102....). 
This entry number is the file descriptor. So it is just an integer number that uniquely represents an opened file in operating 
system. If your process opens 10 files then your Process table will have 10 entries for file descriptors.

3>&1 1>&2 2>&3
The 3>&1 in your command line will create a new file descriptor and redirect it to 1 which is STDOUT. 
Now 1>&2 will redirect the file descriptor 1 to STDERR and 2>&3 will redirect file descriptor 2 to 3 which is STDOUT
------------------------------------------------------------------------------------------------------------------------------

CRON JOBs

# rpm -qa | grep cron  ---------------> -q = querry ; -a = all installed packages
# systemctl status crond.service    ---> to check service status

# crontab -l -----> to list all cron jobs
# cat /etc/crontab    or   crontab -e    ------> to edit crontab or shedule a job

# crontab -e -u <username>  ----> to edit other user crontab
# crontab -l -u <username> ------> to list other user crontab
# crontab -r -u <username> ------> to delete/remove otheruser crontab job

To ALLOW or DENY users to create jobs
# vim /etc cron.allow ----------------> allow user list
# vim /etc cron.deny ----------------> deny user list
# find /etc/ -name "cron.*" -print
    cron.d/       cron.daily/   cron.hourly/  cron.monthly/ cron.weekly/  
      |
      .----> cron.hourly
    juss make entries into this file and it will be executed hourly , weekly, monthly ,... etc
    
Example:-
1. on 33 min 9th hr.... if the day is SUNDAY(0) then only this scrit will be executed
        33 9 8-14 mar * [`date +\%u` = 0] && sh /scripts/testing.sh  
2. */5 * * * * -----> every 5 minutes
3. to monitor cronjob status
       */5 * * * * sh /scripts/testing.sh 2>&1 /test/cron.log | echo "Exit Code" $? >> test/log.log     

-----------------------------------------------------------------------------------------------------------------------------
PROCESS MANAGEMENT

KILL & KILLALL
1 HUP --> hang up  i.e will ask it to reload the configuration file
3 QUIT --> stoprunning
9 KILL --> unconditionally terminate
17 STOP --> stop unconditionally but doesent terminate
18 TSTP --> stop or pauses, but continue to run in background
19 COUNT --> resume execution after STOP or TSTP
       
       -s -------------------> this parameter allow you to specify other signal
# kill -9 <process_id>  ------> to kill only process
# killall -9 httpd*     ------> to kill entire process tree

1. Which user is running which program/services
    # ps -up <process_id>
2. to check which port the service is bind to
    $ sudo netstat -tulpn | grep httpd
3. How do I find which process are started by me?:                  
    # ps -u `whoami`                                        OR                 # pgrep -l -u <user_name>
4. To try to kill all processes owned by a user username.
    # pkill -U username

    
    

Reloading & Restarting the services:-
    Reloading----> during it the process ID does not change
    Restarting---> the process ID changes and the connection associated with this process ID

Enabled & Disabled    
1. To check Status
    # systemctl is-active sshd
2. To check if enabled
    # system is-enabled ssh
   a). To enable--------->  # systemctl enable sshd
   b). To disable---------> # systemctl disable sshd
3. to provide a list  of all the service which are active
    # systemctl list-units --type=service
4. to provide a list  of all the service which are active as well as incative
    # systemctl list-units --type=service --all
5. count 
    # systemctl list-units --type=service | wc -l
6. to list all services which are enabled or disabled
    # systemctl list-unit-files --type=service
7. list of all the services which are failed
    # systemctl --failed --type=service
8. listing all services category-wise
    # systemctl --property --type=service --all

MASKING a service:-
 means if service is running no one can stop it and if the service is stopped no one can stopped it
    # systemctl mask httpd----------------> MASK
    # systemctl unmask httpd--------------> UNMASK
    
=============TIPS & TRICKS=============
1. to view cpu percentage
    # df --output=pcent /dev/sdb4 | awk  'FNR == 2 {print $1}'

-------------------------------------------------------------------------------------------------------------
/etc/   ------------------------------------> hosts.   Allow & Deny

    1. /etc/hosts.allow
    2. /etc/hosts.deny

syntax>>>>
            daemon_list : client_list [: command]

A description of each field follows:
1.    daemon_list: A comma-separated list of daemons, or keyword ALL for all daemons
2.    client_list: A comma-separated list of clients, or keyword ALL for all clients
3.    command: An optional command that is executed when a client tries to access a server daemon

1. To allow clients on the 192.168.2 subnet to access FTP (daemon is vsftpd):
# vi /etc/hosts.allow
    vsftpd : 192.168.2.*

2. To allow all clients to access ssh, scp, and sftp (daemon is sshd):
# vi /etc/hosts.allow
    sshd : ALL

3. Place the following entry in the /etc/hosts.deny file to deny FTP service to all clients except subnet 192.168.2.* (this assumes the previous entry of vsftpd:192.168.2.* exists in /etc/hosts.allow):
# vi /etc/hosts.deny
    vsftpd : ALL

4. Use the .domain syntax to represent any hosts from a given domain. The following example allows connections to vsftpd from any host in the example.com domain (if the entry is in /etc/hosts.allow):
# vi /etc/hosts.allow
    vsftpd : .example.com
----------------------------------------------------------------------------------------------------------

Mounting, Permanet Mounting, /etc/fstab, fdisk:-

0. To list all mounts                         OR                  
    # mount                                                    # df -h
0.0 To unmount
    # umount /dev/vda6
1. List all partition 
    # fdisk -l
2. create partition
    # fdisk /dev/vda -------------> select the partion---------> first create an extended partition and then create logical partitions in it
Formating:-
 # mkfs -t ext3 /dev/sda6 
    
Permanent Mounting:-
    >> Make entry in /etc/fstab and restart the system
    # vim /etc/fstab
        /dev/vda6	/mnt/data	ext4	defaults	0 0   <----------------- make an entry as such

Mounting ----> rw, ro
    >>>> to make any changes first un-mount the partition
    # mount  /dev/vda6 /mnt/data/ -o ro ---------> READ-ONLY       ---------> -o -> to enter multiple options seperated my comma(,)
    # mount  /dev/vda6 /mnt/data/ -o rw ---------> READ-WRITE
    
FSTAB:-   ----------> Its an on-demand mounting command , but its is useful if we have very less mount point
AUTOFS:-  ---------->  Its an on-demand mounting command, but it is better than FSTAB asit mounts and automatically umounts the filesystem/partioin in apre defined timeout value

# rpm -qa | grep autofs   --------> To check if the package is installed or not
# yum install autofs --------> install the autofs package
        NFS  ====>  # showmount -e server    <-------- to list NFS shared volumes
                    /Documents *
                    /Softwares *
# vim /etc/auto.master
   >>>>>> under line >>Make an entry<<<<<<<<<<<<
>>>>>>   /misc   /etc/auto.misc
         /mnt    /etc/test.share --timeout=120     <----------- creating a MAP_File where i will make entrys for mount point
                                            \----> value in second, will be unmount if ideal for more than 120 second
# vim /etc/auto.misc    -----> copy its content and past in 
                                                           |
# vim /etc/test.share                                 <----.
    Softwares -fstype=auto server:/Softwares
     |                                    |
     .---> Mount point in local machime   .-----> NFS server path of the directory
    Documents -fstype=auto server:/Documents
    
=========Tips & Tricks========
1. to view disk usage in percentage
    # df --output=pcent /dev/sdb4------------> select the device
-----------------------------------------------------------------------------------------------    

    

 

   


