6 Stages of Linux Boot Process (Startup Sequence)
   https://www.thegeekstuff.com/2011/02/linux-boot-process
===============================================================================================   

USERADD, USERMOD, USERDEL PASSWD,CHAGE:-
    useradd command is used to create new accounts in Linux
    usermod command used to modify the existing accounts in linux
    userdel command is used to delete local account in linux
    passwd command used assign password to local accounts or users.
    chage comamnd is used to view & modify users password expiry information
>>>>>>>>>>>>>>>>>>>>>> https://www.linuxtechi.com/linux-commands-to-manage-local-accounts   <<<<<<<<<<<<<<<<<<<<<<<

Let’s create a username ‘harry’ and assign password.
    [root@linuxtechi ~]# useradd harry ; echo -e "Roxicant@123#\nRoxicant@123#" | passwd harry
    Changing password for user harry.
    New password: Retype new password: passwd: all authentication tokens updated successfully.
    [root@linuxtechi ~]#
    
**Restricting users with certain for running certain command:-**
==============>
The normal user has been given permission to execute some commands which are available in /bin/ and /usr/local/bin/, So to remove those permissions and to restrict the user to run only particular set of commands, following steps shall be useful.

1. Create the restricted shell.
    # cp /bin/bash /bin/rbash
2. Modify the target user for the shell as restricted shell
  While creating user:
    # useradd -s /bin/rbash localuser
  For existing user:
    # usermod -s /bin/rbash localuser
    
-----------------------------------------------------------------------------------------------
PERMISSIONS:-
======================
Immutable/Mutable - concept

One more step can be added to restrict the user for making any modifications in their .bash_profile , as users can change it.
Run the following command to make the user localuser's .bash_profile file as immutable so that root/localuser can't modify it until root removes immutable permission from it.
    # chattr +i /home/localuser/.bash_profile

To remove immutable tag,
    # chattr -i /home/localuser/.bash_profile

Make file .bash_profile as immutable so that user localuser can't change the environmental paths.

------------------------------------------------------------------------------------------------
Redirection:-                                   +                           FileDescripter
 File 	                File Descriptor
Standard Input STDIN 	0
Standard Output STDOUT 	1
Standard Error STDERR 	2

Examples:-
1.    $ myprogram 2>errorsfile  ---------> error output
2.    # find . -name 'my*' 2>error.log  ----------------> This cmd looks for all files starting with "my" and if it has denied permissions to access the errot log will get redirected to this log file.
3.  Server Administrators frequently, list directories and store both error and standard output into a file, which can be processed later. Here is the command.
      # ls Documents ABC> dirlist 2>&1
      
 Summary

1    Each file in Linux has a corresponding File Descriptor associated with it
2   The keyboard is the standard input device while your screen is the standard output device
3    ">" is the output redirection operator. ">>" appends output to an existing file
4    "<" is the input redirection operator
5    ">&"re-directs output of one file to another.
6    You can re-direct error using its corresponding File Descriptor 2.

joining stdout and stderr  "  &>  "
      The &> construction will put both stdout and stderr in one stream (to a file)

paul@debian7:~$ rm file42 &> out_and_err
paul@debian7:~$ cat out_and_err 
   rm: cannot remove ‘file42’: No such file or directory
   
--------------------------------------------------------------------------------------------


++++++FileDescripter++++++++
In simple words, when you open a file,the operating system creates an entry to represent that file and store the information 
about that opened file. So if there are 100 files opened in your OS then there will be 100 entries in OS (somewhere in kernel). 
These entries are represented by integers like (...100, 101, 102....). 
This entry number is the file descriptor. So it is just an integer number that uniquely represents an opened file in operating 
system. If your process opens 10 files then your Process table will have 10 entries for file descriptors.

3>&1 1>&2 2>&3
The 3>&1 in your command line will create a new file descriptor and redirect it to 1 which is STDOUT. 
Now 1>&2 will redirect the file descriptor 1 to STDERR and 2>&3 will redirect file descriptor 2 to 3 which is STDOUT



noclobber:-
  
  # set -o noclobber   --------> No-overwrite
  # set +o noclobber   --------> can overwrite
  
[paul@RHELv4u3 ~]$ set -o noclobber
[paul@RHELv4u3 ~]$ echo It is cold today! > winter.txt  ----------------------------->          "    >    "
-bash: winter.txt: cannot overwrite existing file  

overruling noclobber

[paul@RHELv4u3 ~]$ echo It is very cold today! >| winter.txt ------------------------>          "    >|   "
[paul@RHELv4u3 ~]$ cat winter.txt It is very cold today!

>> append
[paul@RHELv4u3 ~]$ echo Where is the summer ? >> winter.txt


------------------------------------------------------------------------------------------------------------------------------

CRON JOBs

# rpm -qa | grep cron  ---------------> -q = querry ; -a = all installed packages
# systemctl status crond.service    ---> to check service status

# crontab -l -----> to list all cron jobs
# vim /etc/crontab    or   crontab -e    ------> to edit crontab or shedule a job

# crontab -e -u <username>  ----> to edit other user crontab
# crontab -l -u <username> ------> to list other user crontab
# crontab -r -u <username> ------> to delete/remove otheruser crontab job

To ALLOW or DENY users to create jobs
# vim /etc/cron.deny ----------------> deny user list
# find /etc/ -name "cron.*" -print
    cron.d/       cron.daily/   cron.hourly/  cron.monthly/ cron.weekly/  
      |
      .----> cron.hourly
    juss make entries into this file and it will be executed hourly , weekly, monthly ,... etc
    
Example:-
1. on 33 min 9th hr.... if the day is SUNDAY(0) then only this scrit will be executed
        33 9 8-14 mar * [`date +\%u` = 0] && sh /scripts/testing.sh  
2. */5 * * * * -----> every 5 minutes
3. to monitor cronjob status
       */5 * * * * sh /scripts/testing.sh 2>&1 /test/cron.log | echo "Exit Code" $? >> test/log.log     

-----------------------------------------------------------------------------------------------------------------------------
PROCESS MANAGEMENT

KILL & KILLALL
1 HUP --> hang up  i.e will ask it to reload the configuration file
3 QUIT --> stoprunning
9 KILL --> unconditionally terminate
17 STOP --> stop unconditionally but doesent terminate
18 TSTP --> stop or pauses, but continue to run in background
19 COUNT --> resume execution after STOP or TSTP



    //  Instructs hardware to stop CPU functions.
    halt

    // power off the system
    halt -p

    // reboots the system 
    halt --reboot


       -s -------------------> this parameter allow you to specify other signal
# kill -9 <process_id>  ------> to kill only process
# killall -9 httpd*     ------> to kill entire process tree

1. Which user is running which program/services
    # ps -up <process_id>
2. to check which port the service is bind to
    $ sudo netstat -plunt | grep httpd
3. How do I find which process are started by me?:                  
    # ps -u `whoami`                                        OR                 # pgrep -l -u <user_name>
4. To try to kill all processes owned by a user username.
    # pkill -U username

    
    

Reloading & Restarting the services:-
    Reloading----> during it the process ID does not change
    Restarting---> the process ID changes and the connection associated with this process ID

Enabled & Disabled    
1. To check Status
    # systemctl is-active sshd
2. To check if enabled
    # systemctl is-enabled ssh
   a). To enable--------->  # systemctl enable sshd
   b). To disable---------> # systemctl disable sshd
3. to provide a list  of all the service which are active
    # systemctl list-units --type=service
4. to provide a list  of all the service which are active as well as incative
    # systemctl list-units --type=service --all
5. count 
    # systemctl list-units --type=service | wc -l
6. to list all services which are enabled or disabled
    # systemctl list-unit-files --type=service
7. list of all the services which are failed
    # systemctl --failed --type=service
8. listing all services category-wise
    # systemctl --property --type=service --all

MASKING a service:-
 means if service is running no one can stop it and if the service is stopped no one can stopped it
    # systemctl mask httpd----------------> MASK
    # systemctl unmask httpd--------------> UNMASK
    
=============TIPS & TRICKS=============
1. to view cpu percentage
    # df --output=pcent /dev/sdb4 | awk  'FNR == 2 {print $1}'

-------------------------------------------------------------------------------------------------------------
/etc/   ------------------------------------> hosts.   Allow & Deny

    1. /etc/hosts.allow
    2. /etc/hosts.deny

syntax>>>>
            daemon_list : client_list [: command]

A description of each field follows:
1.    daemon_list: A comma-separated list of daemons, or keyword ALL for all daemons
2.    client_list: A comma-separated list of clients, or keyword ALL for all clients
3.    command: An optional command that is executed when a client tries to access a server daemon

1. To allow clients on the 192.168.2 subnet to access FTP (daemon is vsftpd):
# vi /etc/hosts.allow
    vsftpd : 192.168.2.*

2. To allow all clients to access ssh, scp, and sftp (daemon is sshd):
# vi /etc/hosts.allow
    sshd : ALL

3. Place the following entry in the /etc/hosts.deny file to deny FTP service to all clients except subnet 192.168.2.* (this assumes the previous entry of vsftpd:192.168.2.* exists in /etc/hosts.allow):
# vi /etc/hosts.deny
    vsftpd : ALL

4. Use the .domain syntax to represent any hosts from a given domain. The following example allows connections to vsftpd from any host in the example.com domain (if the entry is in /etc/hosts.allow):
# vi /etc/hosts.allow
    vsftpd : .example.com
----------------------------------------------------------------------------------------------------------

Mounting, Permanet Mounting, /etc/fstab, fdisk:-

0. To list all mounts                         OR                  
    # mount                                                    # df -h
0.0 To unmount
    # umount /dev/vda6
1. List all partition -------------> to list partitions in aparticular partition
    # fdisk -l                            # fdisk /dev/vda2 -l
    
2. create partition
    # fdisk /dev/vda -------------> select the partion---------> first create an extended partition and then create logical partitions in it
Formating:-
 # mkfs -t ext3 /dev/sda6 
    
Permanent Mounting:-
    >> Make entry in /etc/fstab and restart the system
    # vim /etc/fstab
        /dev/vda6	/mnt/data	ext4	defaults	0 0   <----------------- make an entry as such

Mounting ----> rw, ro
    >>>> to make any changes first un-mount the partition
    # mount  /dev/vda6 /mnt/data/ -o ro ---------> READ-ONLY       ---------> -o -> to enter multiple options seperated my comma(,)
    # mount  /dev/vda6 /mnt/data/ -o rw ---------> READ-WRITE
    
FSTAB:-   ----------> Its an on-demand mounting command , but its is useful if we have very less mount point
AUTOFS:-  ---------->  Its an on-demand mounting command, but it is better than FSTAB asit mounts and automatically umounts the filesystem/partioin in apre defined timeout value

# rpm -qa | grep autofs   --------> To check if the package is installed or not
# yum install autofs --------> install the autofs package
        NFS  ====>  # showmount -e server    <-------- to list NFS shared volumes
                    /Documents *
                    /Softwares *
# vim /etc/auto.master
   >>>>>> under line >>Make an entry<<<<<<<<<<<<
>>>>>>   /misc   /etc/auto.misc
         /mnt    /etc/test.share --timeout=120     <----------- creating a MAP_File where i will make entrys for mount point
                                            \----> value in second, will be unmount if ideal for more than 120 second
# vim /etc/auto.misc    -----> copy its content and past in 
                                                           |
# vim /etc/test.share                                 <----.
    Softwares -fstype=auto server:/Softwares
     |                                    |
     .---> Mount point in local machime   .-----> NFS server path of the directory
    Documents -fstype=auto server:/Documents
    
=========Tips & Tricks========
1. to view disk usage in percentage
    # df --output=pcent /dev/sdb4------------> select the device
-----------------------------------------------------------------------------------------------    
 
                      ***        LVM - LOGICAL VOLUME MANAGEMENT:-       ***
                               =====================================
                               
 __/\__   URL:-      https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/logical_volume_manager_administration/lvm_components
                               
Install pacage----.   "  lvm2  "
   # yum install lvm2 -y


Partitions:-
-------------
**Extended Partition is equal to primary partition **


Physical Extents and Logical Extents:- ( minimum size chunks )
--------------------------------------------------------------
URL:-     https://docstore.mik.ua/manuals/hp-ux/en/5992-4589/ch01s03.html

When you create a volume group, you can specify the size of the physical extent for that group (otherwise it will have a
default value of 4MB).
When you make logical volumes, it consists of logical extents, meaning, minimum size chunks, and each logical extent has 
to match the physical extent of the volume group.
Basically, you create a volume group, and you say that your physical extent is 2MB. Whenever you create a logical volume 
from that volume group, the size of that logical volumes has to be an increment of 2. You can specify the size (instead of 
number of extents), but you cant have it be 5MB. It will automatically round it up (if I recall correctly) to 6MB, because 
the extent is 2MB. If your physical extent is 8MB, each logical volume created from that volume group can be the size of 
8,16,24,32MB etc.
So when they ask you to create a logical volume of 32 logical extents, and the physical extent is 8MB, your logical volume 
have 32 chunks of 8MB, so 256MB.

                              Physical Extent size   =   Logical Extent size 


Types of Logical Volume:-
-------------------------
1. linear
2. mirrored  ------------------> mirroring one volum e to another, Such that any write operation performed on one reflects on another.
3. Striped

Linear VS Striped:-    ** URL:- https://sysadmincasts.com/episodes/27-lvm-linear-vs-striped-logical-volumes **
 Linear volumes, writes to the disks in series, as one disk fills up, the next fills, and so on. This is in comparison to 
 how striped logical volumes work. With striped logical volumes, writes head to the disk in a round-robin fashion, so you 
 will actually see much better performance because you are using more disks, and not creating hot spots, or saturating
 one disk in the array.
1. ###############################     
     lvdisplay -vm
    Finding all logical volumes
  --- Logical volume ---
  LV Path                /dev/vol_e27/root
  LV Name                root
  VG Name                vol_e27
  LV UUID                cv5i1M-RDTn-00je-VLar-cvhm-7a5o-H06V24
  LV Write Access        read/write
  LV Creation host, time ip-10-237-150-222, 2014-06-09 06:41:48 +0000
  LV Status              available
  # open                 0
  LV Size                5.82 TiB
  Current LE             1526184
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           252:0
   
  --- Segments ---
  Logical extent 0 to 1526183:                                           
    Type        striped                                               
    Stripes     8                                                 
    Stripe size     256.00 KiB                                      
    Stripe 0:
      Physical volume   /dev/xvdb                         
      Physical extents  0 to 190772                                     
    Stripe 1:                                             
      Physical volume   /dev/xvdc                         
      Physical extents  0 to 190772                       
    Stripe 2:                                             
      Physical volume   /dev/xvdd                         
      Physical extents  0 to 190772                     
    Stripe 3:                                             
      Physical volume   /dev/xvde                       
      Physical extents  0 to 190772                    
    Stripe 4:                                           
      Physical volume   /dev/xvdf                         
      Physical extents  0 to 190772
    Stripe 5:
      Physical volume   /dev/xvdg
      Physical extents  0 to 190772
    Stripe 6:
      Physical volume   /dev/xvdh
      Physical extents  0 to 190772
    Stripe 7:
      Physical volume   /dev/xvdi
      Physical extents  0 to 190772
      
2. #################################      
      
bwm-ng -i disk -I xvdb,xvdc,xvdd,xvde,xvdf,xvdg,xvdh,xvdi

  bwm-ng v0.6 (probing every 0.500s), press 'h' for help
  input: disk IO type: rate
  |         iface                   Rx                   Tx                Total
  ==============================================================================
             xvdb:           0.00 KB/s       279249.51 KB/s       279249.51 KB/s
             xvdc:           0.00 KB/s       275417.17 KB/s       275417.17 KB/s
             xvdd:           0.00 KB/s       280782.44 KB/s       280782.44 KB/s
             xvde:           0.00 KB/s       280135.74 KB/s       280135.74 KB/s
             xvdf:           0.00 KB/s       279760.49 KB/s       279760.49 KB/s
             xvdg:           0.00 KB/s       279249.51 KB/s       279249.51 KB/s
             xvdh:           0.00 KB/s       278994.02 KB/s       278994.02 KB/s
             xvdi:           0.00 KB/s       278483.04 KB/s       278483.04 KB/s
  ------------------------------------------------------------------------------
            total:           0.00 KB/s      2232071.92 KB/s      

Snapshot  vs  Backup:-
-----------------------

A backup is a consistent VM copy that gives you the possibility to restore it in case the original files are compromised
by a disaster or a human mistake. Unlike snapshots, backups are independent of the VM, and they can easily be exported
and stored off premises

BACKUP:- The Storage Networking Industry Association (SNIA) defines a backup in the following way: "A collection of data stored 
on (usually removable) non-volatile storage media for purposes of recovery in case the original copy of data is lost or
becomes inaccessible -- also called a backup copy. To be useful for recovery, a backup must be made by copying the source
data image when it is in a consistent state." The only part of this definition that snapshot-based backups might have 
trouble with is the "usually removable" part, but this is simply SNIA stating the obvious that some backups are placed on tape.

SNIA's definition does bring up one important aspect of snapshot backups: A snapshot is not really a 
backup until it has been replicated to another storage system. This is because a snapshot is a virtual copy of the data,
not an actual copy of the data. If something happens to the volume upon which a snapshot resides, the snapshot of the volume 
will be of no use -- unless it was copied to another volume via replication.

Backup ----> has a central indexing feature, it resides on another storage device(mostly removable), use for complete backup in case of any disaster.
Snapshot --> is self indexed and doesn't have such feature, it resides on same storage device(mostly attached), used mostly for fast backups.

  Assignments:-
-----------------  
1. creating Snapshots
2. Clustered Logical Volume Manager (CLVM)
3. Growing a File System on a Logical Volume:-
      1.Make a new physical volume.
      2.Extend the volume group that contains the logical volume with the file system you are growing to include the new physical volume.
      3.Extend the logical volume to include the new physical volume.
      4.Grow the file system
4. LVM Backups   
5. All message output passes through a logging module with independent choices of logging levels for:
    standard output/error                       URL:-
    syslog                                       >>>  https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/logical_volume_manager_administration/logging
    log file
    external log function 
   The logging levels are set in the /etc/lvm/lvm.conf file, which is described in ( URL:- https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/logical_volume_manager_administration/config_file  )
6. 6.1. Using CLI Commands             >>> URL:-   https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/logical_volume_manager_administration/lvm_cli#CLI_usage
   6.2. Physical Volume Administration
    6.2.1. Creating Physical Volumes
    6.2.2. Displaying Physical Volumes
    6.2.3. Preventing Allocation on a Physical Volume
    6.2.4. Resizing a Physical Volume
    6.2.5. Removing Physical Volumes
7.    











   

    

 

   


